---
title: "{{region}}"
order: {{ order }}
echo: true
engine: knitr
---

```{r}
# Load packages
suppressMessages({
 library(dplyr)
 library(ggplot2)
 library(plotly)
 library(glue)
 library(htmltools)
})

# Query GSIDB
get_data <- function(sql) {
con <- DBI::dbConnect(
  drv = RPostgres::Postgres(),
  dbname = Sys.getenv("POSTGRES_DATABASE"),
  host = Sys.getenv("POSTGRES_HOST"),
  port = Sys.getenv("POSTGRES_PORT"),
  user = Sys.getenv("POSTGRES_USER"),
  password = Sys.getenv("POSTGRES_PASSWORD")
)
on.exit(DBI::dbDisconnect(con))
DBI::dbGetQuery(con, sql)
}

# A table with searching and a download button to export as csv
make_table <- function(data, id, name) {
t_id <- glue('{id}_{name}_table')
file <- glue('{id}_{name}.csv')
tagList(
  tags$div(
    style = "display: flex; justify-content: space-between;",
    tags$button(
      class = "btn btn-sm btn-primary rounded-3",
      "Download as CSV",
      onclick = glue("Reactable.downloadDataCSV('{t_id}', '{file}')")
    ),
    tags$input(
      class = "rt-search",
      type = "text",
      placeholder = "Search",
      oninput = glue("Reactable.setSearch('{t_id}', this.value)")
    )
  ),
  reactable::reactable(
    data, 
    searchable = FALSE,
    showPageSizeOptions = TRUE,
    elementId = t_id
  )
)
}

```
::: {.panel-tabset}

{% for group in groupings %}
## {{ group.0 }}-{{ group.1 }}

### Data By Provider

```{r}
# Set SQL tables and where statements 
table <- switch('{{ group.0 }}',
    "Bottle" = "app.bottle",
    "CTD" = "app.ctd",
    "Mooring" = "app.mooring",
    "Sp Abund" = "app.sp_abund"
)
parameter <- if("{{ group.0 }}" == "Bottle") "analyte" else if("{{ group.0 }}" %in% c("CTD", "Mooring","Sp Abund")) "parameter"
parameter_where <- if(length(parameter)==0) "" else glue(" and {parameter} = '{{ group.1 }}'")
region_where <- if('{{ region }}' == "Global") "" else " and area_id = '{{ region }}'"
```

Table with a summary by data provider (dropdown select for the provider)

```{r}

sql <- glue("
select
    area_id,
    provider,
    {parameter} as parameter,
    extract(year from sample_date) as year, 
    count(*) as n_measurements
from
    {table}
where
    1=1
    {region_where}
    {parameter_where}
group by
    extract(year from sample_date), area_id, provider, {parameter}
order by
    year, provider
")

data <- get_data(sql)
names(data) <- c("Area", "Provider", "Parameter", "Year", "Measurement Count")
if(nrow(data) == 0) {
    cat("No data available")
} else {
 make_table(data, id = "{{region}}_{{group.0}}_{{group.1}}", name = "summary")
} 

```

### Geographical Extent

```{r}

sql <- glue("
select distinct
    location_id, 
    loc_desc as description,
    st_x(st_transform(loc_geom, 4326)) as lon, 
    st_y(st_transform(loc_geom, 4326)) as lat,
    COUNT(*) AS record_count 
from
    {table}
where
    1=1
    and loc_geom is not null
    {region_where}
    {parameter_where}
GROUP BY 
    location_id, loc_desc, lon, lat
")

data <-get_data(sql) |> 
  mutate(tooltip = glue("Location ID: {location_id}<br>Location Description: {description}<br>Sampe Count: {record_count}"))
if(nrow(data) == 0) {
    cat("No data available")
} else {
  # Plotly doesn't auto center map on data points with R
  center_lon <- mean(data$lon)
  center_lat <- mean(data$lat)
  zoom <- ifelse('{{region}}' == "Global", 6, 8)

  plot_ly(
    data = data,
    lon = ~lon,
    lat = ~lat,
    type = 'scattermapbox',
    mode = "markers",
    marker = list(size = 9, line = list(width = 1, color = "black")),
    hovertext = ~tooltip
  ) |> 
  layout(mapbox = list(
    style = "open-street-map",
    center = list(lon = center_lon, lat = center_lat),
    zoom = zoom
  ))
} 
```

### Timeseries

X = month/year, Y = number of samples by month

```{r}

sql <- glue("
select
    date_trunc('month', sample_date)::date as sample_date,
    count(*) as n_measurements
from
    {table}
where
    1=1
    {region_where}
    {parameter_where}
group by
    date_trunc('month', sample_date)::date
")

data <- get_data(sql)
if(nrow(data) == 0) {
    cat("No data available")
} else {
    plot_ly(data, x = ~sample_date, y = ~n_measurements, type = "bar") |> 
    layout(
        title = "Number of Measurements by Month",
        xaxis = list(title = "Sample Date"),
        yaxis = list(title = "Number of Measurements", tickformat = ",d")
    )
} 
```

### Depth distribution

Vertical histogram by depth in 5 meter bins. Histogram should show counts of observations

### Heatmap
::: {.panel-tabset}
#### Heatmap
```{r}
sql <- glue("
select
    area_id,
    {parameter} as parameter,
    extract(year from sample_date) as year,
    extract(month from sample_date) as month,
    count(*) as n_measurements,
    percentile_cont(0.5) within group (order by result) as median,
    string_agg(distinct units, ', ') as units
from
    {table}
where
    1=1
    {region_where}
    {parameter_where}
group by
    extract(year from sample_date),
    extract(month from sample_date),
    area_id, 
    {parameter}
    ")

# query db
data <- get_data(sql) |>
    filter(!is.na(year), !is.na(month))

if(nrow(data) == 0){
    cat("No data available")
}else{
    data <- data |>
      mutate(
        abb_month = factor(month.abb[month], levels = month.abb),
        median = signif(median, digits = 3),
        tooltip = glue::glue(
      "<b>{abb_month} {year}</b>",
      "<b>Count</b>: {format(n_measurements, big.mark = ',')}",
      "<b>Median</b>: {median} {units}",
      .sep = "<br>",
      .na = "--"
    )
      )

  p <- ggplot(data = data, aes(x = abb_month, y = year, fill = median)) + 
  #geom_tile(color = "black", width = 1) +
  ggiraph::geom_tile_interactive(aes(tooltip = tooltip), color = "black", width = 1) +
  scale_fill_distiller(
    palette = "Greens",
    direction = 1,
    na.value = "gray90"
  ) +
  #coord_fixed() + # keep tile as square
  scale_x_discrete(
    breaks = month.abb,
    drop = FALSE,
    expand = c(0,0), 
    position = "top"
  ) +
  scale_y_reverse(expand = c(0,0)) +
  labs(y = "Year", fill = paste0("Median {{ group.1 }}\n(",unique(data$units),")")) +
  theme_bw() +
  theme(
    axis.title.x=element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    #legend.position = "bottom"
  )
ggiraph::girafe(ggobj = p) # interactive charts not showing for global for some reason.
}

```
#### Heatmap Data
The heatmap data contains samples from all depths and locations in a given area. 
```{r}
if(nrow(data) == 0) {
  cat("No data available")
} else{
  data |>
    select(
      Area = area_id,
      Year = year,
      Month = abb_month,
      Parameter = parameter,
      Units = units,
      'Measurement Count' = n_measurements,
      Median = median
  ) |>
  make_table(id = "{{region}}_{{group.0}}_{{group.1}}", name = "heatmap")
}
```
:::
{% endfor %}

:::
